options {
  LOOKAHEAD = 1;
  // FORCE_LA_CHECK = true;
  // DEBUG_PARSER=true;
  MULTI=true;
}

PARSER_BEGIN(parser)
public
class parser {

private
  static int nErrors = 0;
private
  static int MAX_ERRORS = 10;

public
  static void main(String args[]) throws ParseException {
    parser p = new parser(System.in);
    SimpleNode root;

    try{
    root = p.Program();
    }
    catch(ParseException e){
        System.out.println(e.toString());
        return;
    }

    root.dump("");
  }
}
PARSER_END(parser)

/* Caracters to be skipped */
SKIP :
{
    " " |
    "\t" |
    "\r" |
    "\n" |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |         /* Inline comments */
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">    /* Block comments */
}

/* Reserved words */
TOKEN :
{
    < CLASS : "class"> |
    < EXTENDS : "extends" > |
    < PUBLIC : "public"> |
    < STATIC : "static"> |
    < VOID : "void"> |
    < MAIN : "main"> |
    < STRING : "String"> |
    < RETURN : "return"> |
    < INT : "int"> |
    < BOOL : "boolean"> |
    < IF : "if"> |
    < ELSE : "else"> |
    < WHILE : "while"> |
    < LENGTH : "length"> |
    < T : "true"> |
    < F : "false"> |
    < THIS : "this"> |
    < NEW : "new">
}

/* Stuff :) */
TOKEN :
{
    < L_PAR : "("> | 
    < R_PAR : ")"> | 
    < L_BRACE : "{"> | 
    < R_BRACE : "}"> | 
    < L_BRACKET : "["> | 
    < R_BRACKET : "]"> | 
    < SEMICOLON : ";"> | 
    < COMMA : ","> | 
    < DOT : ".">
}

/* Operations */
TOKEN :
{
    < ASSIGN : "="> | 
    < AND : "&&"> | 
    < LESSTHAN : "<"> | 
    < SUM : "+"> | 
    < SUB : "-"> | 
    < MULT : "*"> | 
    < DIV : "/"> |
    < NOT : "!">
}

/* IntegerLiteral and Identifiers */
TOKEN :
{
    < INTEGER_LITERAL : <DECIMAL> | <OCTAL> | <HEXADECIMAL> | <BINARY> > |
    < #DECIMAL: ["1"-"9"](["0"-"9"])* > |
    < #OCTAL: "0"(["0"-"7"])* > |
    < #HEXADECIMAL: ("0x" | "0X")(["0"-"9", "A"-"F", "a"-"f"])+ > |
    < #BINARY: ("0b" | "0B")(["0", "1"])+ > |
    
    < IDENTIFIER : <LETTER> (<LETTER>|<DIGIT>)* > |
    < #LETTER : ["$", "_", "a"-"z", "A"-"Z"] > |
    < #DIGIT : ["0"-"9"] >
}

SimpleNode Program(): {}
{
  ClassDeclaration()<EOF> { return jjtThis; }
}

/**
 * Class declaration
 */
void ClassDeclaration() : {Token id, ext;} {
<CLASS> id=<IDENTIFIER> {jjtThis.id = id;} (<EXTENDS> ext=<IDENTIFIER> {jjtThis.ext = ext;})? 
    <L_BRACE> 
        ( VarDeclaration() )*
        ( <PUBLIC> ( MainDeclaration() | MethodDeclaration() ) )* 
    <R_BRACE>
}

/**
 * Variable declaration
 */
void VarDeclaration() : {Token id;} { id=Type()<IDENTIFIER><SEMICOLON> {jjtThis.id = id;} }

/**
 * Main function declaration
 */
void MainDeclaration() : {Token id;} {
<STATIC> <VOID> <MAIN> <L_PAR> <STRING> <L_BRACKET> <R_BRACKET> id=<IDENTIFIER> <R_PAR> {jjtThis.id = id;}
    <L_BRACE>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
    <R_BRACE>
}

/**
 * Method declaration
 */
void MethodDeclaration() : {Token id;} {
    Type() id=<IDENTIFIER><L_PAR> Args()<R_PAR> {jjtThis.id = id;}
    <L_BRACE>(LOOKAHEAD(2) VarDeclaration()) * (Statement()) *
    <RETURN> Expression()<SEMICOLON><R_BRACE>
}

/**
 * Arguments
 */
void Args() : {} { (Arg() (<COMMA> Arg()) *) ? }

/**
 * Argument
 */
void Arg() : {Token id;} { Type() id=<IDENTIFIER> {jjtThis.id = id;} }

/**
 * Types possible
 *      int[]
 *      boolean
 *      <identifier>
 */
void Type() : {} {
    ( <INT> {jjtThis.type = "int";} ( <L_BRACKET> <R_BRACKET> {jjtThis.array = true;} )? ) |
    <BOOL> {jjtThis.type = "bool";} |
    <IDENTIFIER> {jjtThis.type = "id";}
}

/**
 * Statements
 *      If then else blocks
 *      Assign values
 */
void Statement() : {Token id;} {
  (<L_BRACE> Statement() < R_BRACE >) |
  (If()) {jjtThis.type = "if";} | 
  (While()) {jjtThis.type = "while";} |
  (id=<IDENTIFIER> {jjtThis.type = "id";} (<L_BRACKET> Expression() < R_BRACKET > {jjtThis.array = true;} | {}) ( (<ASSIGN> Expression() < SEMICOLON > {jjtThis.assign = true;} ) | (Expression_Alt() < SEMICOLON > ))) |
  (ExpressionNoId() < SEMICOLON > {jjtThis.type = "no_id";})
}

void If() : {} {
  try {
    <IF><L_PAR> Expression()<R_PAR> Statement()<ELSE> Statement()
  } catch (ParseException e) {
    reportError(e, "IF", false);
  }
}

void While() : {} {

    <WHILE><L_PAR>

  try {
     Expression()
  } catch (ParseException e) {
    reportError(e, "WHILE", true);
  }

  <R_PAR> Statement()
}

JAVACODE
void recoverFromError() {
  Token t;
  do {
    t = getToken(1);
    if (t.kind == R_PAR)
      return;
    t = getNextToken();
  } while (t.kind != R_PAR);
}

JAVACODE
void reportError(ParseException e, String statement, boolean recover) {
  System.out.println("Syntatic error on " + statement + " statement.\n\n" +
                     e.toString());
  nErrors++;

  if (recover) {
    recoverFromError();
  }

  if (nErrors >= MAX_ERRORS) {
    System.out.println("Reached maximum number of errors (" + MAX_ERRORS +
                       "). Terminating.");
    System.exit(1);
  }
}

/**
 * Expressions    
 */
void Expression() #void : {}
{
    And()
}

void And() #void : {}
{
    LT() ( LOOKAHEAD(2) <AND> LT() #and(2))*
}

void LT() #void : {}
{
    Sum() ( LOOKAHEAD(2) <LESSTHAN> Sum() #lt(2))*
}

void Sum() #void : {}
{
    Sub() ( LOOKAHEAD(2) <SUM> Sub() #sum(2))*
}

void Sub() #void : {}
{
    Mult() ( LOOKAHEAD(2) <SUB> Mult() #sub(2))*
}

void Mult() #void : {}
{
    Div() ( LOOKAHEAD(2) <MULT> Div() #mult(2))*
}

void Div() #void : {}
{
    LowerExpression() ( LOOKAHEAD(2) <DIV> LowerExpression() #div(2))*
}

void LowerExpression() #void : {Token t;}
{
    ( t=<INTEGER_LITERAL> Expression_Alt() #literal {jjtThis.info = t;} )| 
    ( <T> Expression_Alt() #bool {jjtThis.info = true;} ) |
    ( <F> Expression_Alt() #bool ) |
    ( t=<IDENTIFIER> Expression_Alt() #id {jjtThis.info = t;}) |
    ( <THIS> Expression_Alt() #_this ) |
    ( <NEW> #_new ( ( <INT> <L_BRACKET> Expression() <R_BRACKET> Expression_Alt() {jjtThis.type = "array";} ) |
                   ( t=<IDENTIFIER> <L_PAR> <R_PAR> Expression_Alt() {jjtThis.type = "id"; jjtThis.info = t;) ) ) |
    ( <NOT> Expression() Expression_Alt() #not ) |
    ( <L_PAR> Expression() <R_PAR> Expression_Alt() )
}

void ExpressionNoId() #void : {Token t;}
{
    ( t=<INTEGER_LITERAL> Expression_Alt() #literal {jjtThis.info = t;} )| 
    ( <T> Expression_Alt() #bool {jjtThis.info = true;} ) |
    ( <F> Expression_Alt() #bool ) |
    ( <THIS> Expression_Alt() #_this ) |
    ( <NEW> #_new ( ( <INT> <L_BRACKET> Expression() <R_BRACKET> Expression_Alt() {jjtThis.type = "array";}) |
                   ( t=<IDENTIFIER> <L_PAR> <R_PAR> Expression_Alt() {jjtThis.type = "id"; jjtThis.info = t;} ) ) ) |
    ( <NOT> Expression() Expression_Alt() #not ) |
    ( <L_PAR> Expression() <R_PAR> Expression_Alt() )
}

/**
 * Auxiliar expression - to prevent left side recursion
 */
void Expression_Alt() #void : {Token t;}
{
    ( <L_BRACKET> Expression() <R_BRACKET> Expression_Alt() ) |
    ( <DOT> #field ( ( <LENGTH> Expression_Alt() {jjtThis.type = "length") ) |
                     ( t=<IDENTIFIER> <L_PAR> ( Expression() ( <COMMA> Expression() )* )? <R_PAR> Expression_Alt() {jjtThis.type = "id"; jjtThis.info = t;} ) ) |
    {}
}