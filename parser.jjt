options
{
    LOOKAHEAD=1;
    // MULTI=true;
}

PARSER_BEGIN(parser)
    public class parser
    {
        public static void main(String args[]) throws ParseException {
            parser p = new parser(System.in);
            SimpleNode root = p.Program();

            root.dump("");
        }
    }
PARSER_END(parser)

SKIP :
{
    " " |
    "\t" |
    "\r" |
    "\n" |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN :
{
    < INTEGER_LITERAL : <DECIMAL> | <OCTAL> | <HEXADECIMAL> | <BINARY> > |
    < #DECIMAL: ["1"-"9"](["0"-"9"])* > |
    < #OCTAL: "0"(["0"-"7"])* > |
    < #HEXADECIMAL: ("0x" | "0X")(["0"-"9", "A"-"F", "a"-"f"])+ > |
    < #BINARY: ("0b" | "0B")(["0", "1"])+ > |
    
    < IDENTIFIER : <LETTER> (<LETTER>|<DIGIT>)* > |
    < #LETTER : ["$", "_", "a"-"z", "A"-"Z"] > |
    < #DIGIT : ["0"-"9"] >
}

TOKEN :
{
    < CLASS : "class"> |
    < EXTENDS : "extends" > |
    < PUBLIC : "public"> |
    < STATIC : "static"> |
    < VOID : "void"> |
    < MAIN : "main"> |
    < STRING : "String"> |
    < RETURN : "return"> |
    < INT : "int"> |
    < BOOL : "boolean"> |
    < IF : "if"> |
    < ELSE : "else"> |
    < WHILE : "while"> |
    < LENGTH : "length"> |
    < T : "true"> |
    < F : "false"> |
    < THIS : "this"> |
    < NEW : "new">
}

TOKEN :
{
    < L_PAR : "("> | 
    < R_PAR : ")"> | 
    < L_BRACE : "{"> | 
    < R_BRACE : "}"> | 
    < L_BRACKET : "["> | 
    < R_BRACKET : "]"> | 
    < SEMICOLON : ";"> | 
    < COMMA : ","> | 
    < DOT : ".">
}

TOKEN :
{
    < ASSIGN : "="> | 
    < AND : "&&"> | 
    < LESSTHAN : "<"> | 
    < SUM : "+"> | 
    < SUB : "-"> | 
    < MULT : "*"> | 
    < DIV : "/"> |
    < NOT : "!">
}

SimpleNode Program(): {}
{
    ClassDeclaration() <EOF> {return jjtThis;}
}

void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? 
    <L_BRACE> 
        ( VarDeclaration() )*
        ( MainDeclaration() | MethodDeclaration() )* 
    <R_BRACE>
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MainDeclaration() : {}
{
    <PUBLIC> <STATIC> <VOID> <MAIN> <L_PAR> <STRING> <L_BRACKET> <R_BRACKET> <IDENTIFIER> <R_PAR>
    <L_BRACE>
        ( VarDeclaration() )*
        ( Statement() )*
    <R_BRACE>
}   

void MethodDeclaration() : {}
{
    <PUBLIC> Type() <IDENTIFIER> <L_PAR> Args() <R_PAR>
    <L_BRACE>
        ( VarDeclaration() )*
        ( Statement() )*
        <RETURN> Expression() <SEMICOLON>
    <R_BRACE>
}

void Args() : {}
{
    ( Type() <IDENTIFIER> 
      (<COMMA> Type() <IDENTIFIER> ) * )?
}

void Type() : {}
{
    ( <INT> <L_BRACKET> <R_BRACKET> ) |
    <BOOL> |
    <INT> | 
    <IDENTIFIER>
}

void Statement() : {}
{
    ( <L_BRACE> Statement() <R_BRACE> ) |
    ( <IF> <L_PAR> Expression() <R_PAR> Statement() <ELSE> Statement() ) | 
    ( <WHILE> <L_PAR> Expression() <R_PAR> Statement() ) |
    ( Expression() <SEMICOLON> ) | 
    ( <IDENTIFIER> <ASSIGN> Expression() <SEMICOLON> ) |
    ( <IDENTIFIER> <L_BRACKET> Expression() <R_BRACKET> <ASSIGN> Expression() <SEMICOLON> )
}

void Expression() : {}
{
    ( Expression() Op()  Expression() ) |
    ( Expression() <L_BRACKET> Op() <R_BRACKET> ) |
    ( Expression() <DOT> <LENGTH> ) |
    ( Expression() <DOT> <IDENTIFIER> <L_PAR> ( Expression() ( <COMMA> Expression() )* )?  ) |
    <INTEGER_LITERAL> | 
    <T> |
    <F> |
    <IDENTIFIER> |
    <THIS> |
    ( <NEW> <INT> <L_BRACKET> Expression() <R_BRACKET> ) |
    ( <NEW> <IDENTIFIER> <L_PAR> <R_PAR> ) |
    ( <NOT> Expression() ) |
    ( <L_PAR> Expression() <R_PAR> )
}

void Op() : {}
{
    <AND> | 
    <LESSTHAN> |
    <SUM> |
    <SUB> |
    <MULT> |
    <DIV>
}